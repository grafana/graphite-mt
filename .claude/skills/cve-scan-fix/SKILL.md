# Find and Fix CVEs

A skill for scanning Docker images for security vulnerabilities and applying minimal fixes iteratively until the image is clean.

## Prerequisites

The following tools must be installed before this skill can run. If any are missing, **stop and ask the user to install them** — do not attempt to install them yourself.

- `docker` - for building images
- `grype` - Anchore vulnerability scanner
- `trivy` - Aqua Security vulnerability scanner

Check with:
```bash
command -v grype || echo "grype not installed"
command -v trivy || echo "trivy not installed"
```

## Principles

- **Fixes must be minimal and easy to review** — prefer targeted changes (upgrade a specific package, change a base image tag) over broad ones (e.g., `apt-get upgrade -y`). Each fix should be explainable in one sentence.
- **Tests must pass** — after every round of fixes, run `graphite/test.sh` and confirm all tests pass before proceeding. A fix that breaks functionality is not acceptable.
- **"No fix" on an EOL OS is not the same as "no fix"** — grype reports "no fix" for packages on end-of-life distros because the distro stopped backporting patches. The fix is to upgrade the base image. Never skip High/Critical CVEs just because grype says "no fix" — check whether the OS is EOL first.

## Workflow

### Step 1: Build the image

```bash
make build
```

### Step 2: Scan with both tools

Always redirect grype stderr away from the JSON file — it mixes progress output into stdout:

```bash
IMAGE_NAME="us.gcr.io/kubernetes-dev/graphite-mt:$(cat .docker_tag)" && \
  grype "${IMAGE_NAME}" -o json 2>/dev/null > /tmp/grype-results.json
IMAGE_NAME="us.gcr.io/kubernetes-dev/graphite-mt:$(cat .docker_tag)" && \
  trivy image --format json --output /tmp/trivy-results.json "${IMAGE_NAME}"
```

**Command hygiene**: Always start scan commands with `IMAGE_NAME="us.gcr.io/kubernetes-dev/graphite-mt:$(cat .docker_tag)" &&` — this prefix is pre-approved and covers the subshell. Use the `Read` tool for reading files like `Dockerfile`; never `cat` via Bash for standalone file reads.

**Pay attention to trivy's stderr warnings** — if it prints "This OS version is no longer supported by the distribution", the base image is EOL and must be upgraded before doing anything else (see Step 3).

Parse and display grype results grouped by severity:

```python
import json
with open('/tmp/grype-results.json') as f:
    data = json.load(f)
matches = data.get('matches', [])
by_sev = {}
for m in matches:
    sev = m['vulnerability'].get('severity', 'Unknown')
    by_sev.setdefault(sev, []).append(m)

for sev in ['Critical', 'High', 'Medium', 'Low', 'Negligible']:
    items = by_sev.get(sev, [])
    if items:
        print(f'\n=== {sev} ({len(items)}) ===')
        for m in items:
            v = m['vulnerability']
            art = m['artifact']
            fix = v.get('fix', {}).get('versions', [])
            print(f'  {v["id"]:25s} {art["name"]:30s} {art["version"]:20s} -> {", ".join(fix) or "no fix"}')
```

### Step 3: Triage findings

**If trivy reported the OS is EOL**, upgrade the base image first (see below). Do not triage individual CVEs yet — most "no fix" entries will disappear once the OS is current.

**If the OS is supported**, for each CVE determine:
1. Is a fix available in grype? If not, skip it.
2. What type of fix is needed — base image upgrade, apt package upgrade, or pip package upgrade?
3. What is the minimal change to apply it?

Group fixable CVEs by fix type before making any changes.

### Step 4: Apply fixes

Apply one category of fix at a time, rebuild, and re-scan between rounds to confirm improvement.

#### Base image upgrade (do this first when OS is EOL)

When trivy warns that the OS is end-of-life, upgrading the base image is mandatory — it is the single highest-impact fix and unlocks fixes for all the CVEs that grype was reporting as "no fix" simply because the distro stopped backporting patches. Choose the next supported Ubuntu LTS.

**Compatibility checklist when moving between Ubuntu LTS versions:**
- Verify all explicitly installed packages still exist under the same name
- Check for package renames (e.g., `libffi7` → `libffi8` between focal and jammy)
- Check default Python version — it changes between LTS releases, and older versions may not be available in the default repos; update all references in the Dockerfile: package names (e.g. `python3.9` → `python3.10`), pip invocations, and virtualenv paths (`lib/python3.x/`)
- Check for missing transitive dependencies — minimal Docker base images pull in fewer packages than full installs; packages that were implicit before may need to be added explicitly (e.g., `tzdata` is needed for Python's `zoneinfo` module on jammy)

#### System packages with fixes available

When a package fix exists but the package was installed by the base image layer (not your Dockerfile), apt won't upgrade it during your install step. Use `--only-upgrade` to upgrade it specifically without installing anything else:

```dockerfile
RUN apt-get update && \
    apt-get install -y --only-upgrade <package-name> && \
    apt-get install -y <your other packages> && \
    rm -rf /var/lib/apt/lists/*
```

#### Python/pip package CVEs

Add the affected package to the security-updates pip install line:

```dockerfile
# Security updates
RUN /opt/graphite/bin/pip install --upgrade <package>
```

### Step 5: Verify

After each round of fixes:

1. Rebuild: `make build`
2. Re-scan: repeat Step 2
3. Run tests: `bash graphite/test.sh` — **all tests must pass**
4. If tests fail, the fix must be revised before continuing

Repeat until no Critical/High remain and all fixable Medium/Low are resolved.

### Step 6: Report

Summarize what was changed and what remains:

```
Changes made:
- <minimal description of each fix>

Remaining CVEs (no fix available):
- <severity>: <CVE-ID> in <package> — upstream patch pending
```
